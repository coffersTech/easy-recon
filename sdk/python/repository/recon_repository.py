import logging
import mysql.connector
try:
    import psycopg2
    import psycopg2.extras
except ImportError:
    psycopg2 = None
from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from config.recon_config import ReconConfig
from entity.recon_order_main import ReconOrderMain
from entity.recon_order_split_sub import ReconOrderSplitSub
from entity.recon_exception import ReconException
from entity.recon_notify_log import ReconNotifyLog
from entity.recon_order_refund_split_sub import ReconOrderRefundSplitSub
from entity.recon_summary import ReconSummary

logger = logging.getLogger(__name__)

class ReconRepository:
    """
    Recon Repository implementation using mysql-connector-python
    """

    def __init__(self, config: ReconConfig):
        self.config = config
        self.db_config = {
            "host": config.db_host,
            "port": config.db_port,
            "user": config.db_user,
            "password": config.db_password,
            "database": config.db_name,
            "pool_name": config.pool_name,
            "pool_size": config.pool_size
        }
        
        if config.auto_create_table:
            self.init_schema()
    
    def init_schema(self):
        """Initialize database schema if not exists"""
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            
            auto_inc = "AUTO_INCREMENT"
            if self.config.db_type == "postgresql":
                auto_inc = "GENERATED BY DEFAULT AS IDENTITY" # or SERIAL logic if creating new, but identity is standard in modern PG
            
            # Recon Order Main
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS easy_recon_order_main (
                    order_no VARCHAR(64) PRIMARY KEY,
                    pay_amount DECIMAL(18,2),
                    platform_income DECIMAL(18,2),
                    pay_fee DECIMAL(18,2),
                    split_total_amount DECIMAL(18,2),
                    pay_status INT,
                    split_status INT,
                    notify_status INT,
                    recon_status INT,
                    notify_result TEXT,
                    refund_status INT,
                    refund_amount DECIMAL(18,2),
                    refund_time TIMESTAMP,
                    create_time TIMESTAMP,
                    update_time TIMESTAMP
                )
            """)
            
            # Recon Order Split Sub
            if self.config.db_type == "postgresql":
                 cursor.execute(f"""
                    CREATE TABLE IF NOT EXISTS easy_recon_order_split_sub (
                        id SERIAL PRIMARY KEY,
                        order_no VARCHAR(64),
                        sub_order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        merchant_order_no VARCHAR(64),
                        split_amount DECIMAL(18,2),
                        notify_status INT,
                        notify_result TEXT,
                        create_time TIMESTAMP,
                        update_time TIMESTAMP
                    )
                """)
                 # Create indexes separately for PG if not exists (simple way: just create table)
                 # keeping it simple for demo
                 cursor.execute("CREATE INDEX IF NOT EXISTS idx_order_split_sub_order_no ON easy_recon_order_split_sub (order_no)")
            else:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS easy_recon_order_split_sub (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        order_no VARCHAR(64),
                        sub_order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        merchant_order_no VARCHAR(64),
                        split_amount DECIMAL(18,2),
                        notify_status INT,
                        notify_result TEXT,
                        create_time DATETIME,
                        update_time DATETIME,
                        INDEX idx_order_no (order_no),
                        INDEX idx_sub_order_no (sub_order_no),
                        INDEX idx_merchant_order (merchant_id, merchant_order_no)
                    )
                """)
            
            # Recon Order Refund Split Sub
            if self.config.db_type == "postgresql":
                cursor.execute(f"""
                    CREATE TABLE IF NOT EXISTS easy_recon_order_refund_split_sub (
                        id SERIAL PRIMARY KEY,
                        order_no VARCHAR(64),
                        sub_order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        merchant_order_no VARCHAR(64),
                        refund_split_amount DECIMAL(18,2),
                        create_time TIMESTAMP,
                        update_time TIMESTAMP
                    )
                """)
            else:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS easy_recon_order_refund_split_sub (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        order_no VARCHAR(64),
                        sub_order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        merchant_order_no VARCHAR(64),
                        refund_split_amount DECIMAL(18,2),
                        create_time DATETIME,
                        update_time DATETIME,
                        INDEX idx_order_no (order_no)
                    )
                """)
            
            # Exception
            if self.config.db_type == "postgresql":
                cursor.execute(f"""
                    CREATE TABLE IF NOT EXISTS easy_recon_exception (
                        id SERIAL PRIMARY KEY,
                        order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        exception_msg TEXT,
                        exception_step INT,
                        create_time TIMESTAMP,
                        update_time TIMESTAMP
                    )
                """)
            else:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS easy_recon_exception (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        exception_msg TEXT,
                        exception_step INT,
                        create_time DATETIME,
                        update_time DATETIME,
                        INDEX idx_order_no (order_no)
                    )
                """)
            
            # Notify Log
            if self.config.db_type == "postgresql":
                cursor.execute(f"""
                    CREATE TABLE IF NOT EXISTS easy_recon_notify_log (
                        id SERIAL PRIMARY KEY,
                        order_no VARCHAR(64),
                        sub_order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        notify_url VARCHAR(255),
                        notify_status INT,
                        notify_result TEXT,
                        create_time TIMESTAMP,
                        update_time TIMESTAMP
                    )
                """)
            else:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS easy_recon_notify_log (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        order_no VARCHAR(64),
                        sub_order_no VARCHAR(64),
                        merchant_id VARCHAR(64),
                        notify_url VARCHAR(255),
                        notify_status INT,
                        notify_result TEXT,
                        create_time DATETIME,
                        update_time DATETIME,
                        INDEX idx_order_no (order_no)
                    )
                """)
            
            conn.commit()
        except Exception as e:
            logger.error(f"Failed to init schema: {e}")
        finally:
            if cursor: cursor.close()
            if conn: conn.close()
    
    def get_connection(self):
        if self.config.db_type == "postgresql":
            if not psycopg2:
                raise ImportError("psycopg2 is not installed. Please install psycopg2-binary.")
            return psycopg2.connect(
                host=self.config.db_host,
                port=self.config.db_port,
                user=self.config.db_user,
                password=self.config.db_password,
                dbname=self.config.db_name
            )
        else:
            return mysql.connector.connect(**self.db_config)

    def save_order_main(self, order_main: ReconOrderMain) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_main"
            if self.config.db_type == "postgresql":
                sql = f"""
                    INSERT INTO {table_name} (
                        order_no, pay_amount, platform_income, pay_fee, split_total_amount,
                        pay_status, split_status, notify_status, recon_status, 
                        notify_result, create_time, update_time
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ON CONFLICT (order_no) DO UPDATE SET
                        pay_amount = EXCLUDED.pay_amount,
                        platform_income = EXCLUDED.platform_income,
                        pay_fee = EXCLUDED.pay_fee,
                        split_total_amount = EXCLUDED.split_total_amount,
                        pay_status = EXCLUDED.pay_status,
                        split_status = EXCLUDED.split_status,
                        notify_status = EXCLUDED.notify_status,
                        recon_status = EXCLUDED.recon_status,
                        notify_result = EXCLUDED.notify_result,
                        update_time = EXCLUDED.update_time
                """
            else:
                sql = f"""
                    INSERT INTO {table_name} (
                        order_no, pay_amount, platform_income, pay_fee, split_total_amount,
                        pay_status, split_status, notify_status, recon_status, 
                        notify_result, create_time, update_time
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE
                        pay_amount = VALUES(pay_amount),
                        platform_income = VALUES(platform_income),
                        pay_fee = VALUES(pay_fee),
                        split_total_amount = VALUES(split_total_amount),
                        pay_status = VALUES(pay_status),
                        split_status = VALUES(split_status),
                        notify_status = VALUES(notify_status),
                        recon_status = VALUES(recon_status),
                        notify_result = VALUES(notify_result),
                        update_time = VALUES(update_time)
                """
            params = (
                order_main.order_no, order_main.pay_amount, order_main.platform_income, 
                order_main.pay_fee, order_main.split_total_amount,
                order_main.pay_status, order_main.split_status, order_main.notify_status, 
                order_main.recon_status, order_main.notify_result,
                order_main.create_time or datetime.now(), order_main.update_time or datetime.now()
            )
            cursor.execute(sql, params)
            conn.commit()
            return cursor.rowcount > 0 or True # rowcount might be 0 on duplicate key update with same values
        except Exception as e:
            logger.error(f"Failed to save order main: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_order_main(self, order_no: str) -> Optional[ReconOrderMain]:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            if self.config.db_type == "postgresql":
                cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
                sql = "SELECT * FROM easy_recon_order_main WHERE order_no = %s"
                cursor.execute(sql, (order_no,))
            else:
                cursor = conn.cursor(dictionary=True)
                sql = "SELECT * FROM easy_recon_order_main WHERE order_no = %s"
                cursor.execute(sql, (order_no,))
            row = cursor.fetchone()
            if row:
                return ReconOrderMain(
                    order_no=row['order_no'],
                    pay_amount=row['pay_amount'],
                    platform_income=row['platform_income'],
                    pay_fee=row['pay_fee'],
                    split_total_amount=row['split_total_amount'],
                    pay_status=row['pay_status'],
                    split_status=row['split_status'],
                    notify_status=row['notify_status'],
                    recon_status=row['recon_status'],
                    notify_result=row['notify_result'],
                    create_time=row['create_time'],
                    update_time=row['update_time'],
                    refund_status=row.get('refund_status'),
                    refund_amount=row.get('refund_amount'),
                    refund_time=row.get('refund_time')
                )
            return None
        except Exception as e:
            logger.error(f"Failed to get order main: {e}")
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def batch_save_order_split_sub(self, split_subs: List[ReconOrderSplitSub]) -> bool:
        if not split_subs:
            return True
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_split_sub"
            sql = f"""
                INSERT INTO {table_name} (
                    order_no, sub_order_no, merchant_id, merchant_order_no, split_amount,
                    notify_status, notify_result, create_time, update_time
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            params = []
            now = datetime.now()
            for sub in split_subs:
                params.append((
                    sub.order_no, sub.sub_order_no, sub.merchant_id, sub.merchant_order_no,
                    sub.split_amount, sub.notify_status, sub.notify_result,
                    sub.create_time or now, sub.update_time or now
                ))
            cursor.executemany(sql, params)
            conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to batch save split subs: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_split_subs(self, order_no: str) -> List[ReconOrderSplitSub]:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            if self.config.db_type == "postgresql":
                cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
                sql = "SELECT * FROM easy_recon_order_split_sub WHERE order_no = %s"
            else:
                cursor = conn.cursor(dictionary=True)
                sql = "SELECT * FROM easy_recon_order_split_sub WHERE order_no = %s"
            
            cursor.execute(sql, (order_no,))
            rows = cursor.fetchall()
            result = []
            for row in rows:
                result.append(ReconOrderSplitSub(
                    order_no=row['order_no'],
                    sub_order_no=row['sub_order_no'],
                    merchant_id=row['merchant_id'],
                    merchant_order_no=row['merchant_order_no'],
                    split_amount=row['split_amount'],
                    notify_status=row['notify_status'],
                    notify_result=row['notify_result'],
                    create_time=row['create_time'],
                    update_time=row['update_time']
                ))
            return result
        except Exception as e:
            logger.error(f"Failed to get split subs: {e}")
            return []
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def save_exception(self, exception: ReconException) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_exception"
            sql = f"""
                INSERT INTO {table_name} (
                    order_no, merchant_id, exception_msg, exception_step, create_time, update_time
                ) VALUES (%s, %s, %s, %s, %s, %s)
            """
            params = (
                exception.order_no, exception.merchant_id, exception.exception_msg,
                exception.exception_step, exception.create_time or datetime.now(),
                exception.update_time or datetime.now()
            )
            cursor.execute(sql, params)
            conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to save exception: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def save_notify_log(self, notify_log: ReconNotifyLog) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_notify_log"
            sql = f"""
                INSERT INTO {table_name} (
                    order_no, sub_order_no, merchant_id, notify_url, notify_status,
                    notify_result, create_time, update_time
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """
            params = (
                notify_log.order_no, notify_log.sub_order_no, notify_log.merchant_id,
                notify_log.notify_url, notify_log.notify_status, notify_log.notify_result,
                notify_log.create_time or datetime.now(), notify_log.update_time or datetime.now()
            )
            cursor.execute(sql, params)
            conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to save notify log: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_recon_status(self, order_no: str, recon_status: int) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_main"
            sql = f"UPDATE {table_name} SET recon_status = %s, update_time = %s WHERE order_no = %s"
            cursor.execute(sql, (recon_status, datetime.now(), order_no))
            conn.commit()
            return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"Failed to update recon status: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()
            
    def update_notify_status(self, order_no: str, notify_status: int, notify_result: str) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_main"
            sql = f"UPDATE {table_name} SET notify_status = %s, notify_result = %s, update_time = %s WHERE order_no = %s"
            cursor.execute(sql, (notify_status, notify_result, datetime.now(), order_no))
            conn.commit()
            return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"Failed to update notify status: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_split_sub_notify_status(self, order_no: str, merchant_id: str, sub_order_no: Optional[str], 
                                     notify_status: int, notify_result: str) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_split_sub"
            sql = f"UPDATE {table_name} SET notify_status = %s, notify_result = %s, update_time = %s WHERE order_no = %s AND merchant_id = %s"
            params = [notify_status, notify_result, datetime.now(), order_no, merchant_id]
            if sub_order_no:
                sql += " AND sub_order_no = %s"
                params.append(sub_order_no)
            cursor.execute(sql, tuple(params))
            conn.commit()
            return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"Failed to update split sub notify status: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def is_all_split_sub_notified(self, order_no: str) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_split_sub"
            # Return True if NO records have notify_status != 1 (SUCCESS)
            sql = f"SELECT count(*) FROM {table_name} WHERE order_no = %s AND notify_status != 1"
            cursor.execute(sql, (order_no,))
            count = cursor.fetchone()[0]
            return count == 0
        except Exception as e:
            logger.error(f"Failed to check all split sub notified: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def find_order_no_by_sub(self, merchant_id: str, sub_order_no: str) -> Optional[str]:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_split_sub"
            sql = f"SELECT order_no FROM {table_name} WHERE merchant_id = %s AND sub_order_no = %s LIMIT 1"
            cursor.execute(sql, (merchant_id, sub_order_no))
            row = cursor.fetchone()
            return row[0] if row else None
        except Exception as e:
            logger.error(f"Failed to find order no by sub: {e}")
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def find_order_no_by_merchant_order(self, merchant_id: str, merchant_order_no: str) -> Optional[str]:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_split_sub"
            sql = f"SELECT order_no FROM {table_name} WHERE merchant_id = %s AND merchant_order_no = %s LIMIT 1"
            cursor.execute(sql, (merchant_id, merchant_order_no))
            row = cursor.fetchone()
            return row[0] if row else None
        except Exception as e:
            logger.error(f"Failed to find order no by merchant order: {e}")
            return None
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def update_recon_refund_status(self, order_no: str, refund_status: int, 
                                 refund_amount: float, refund_time: datetime) -> bool:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_main"
            sql = f"""
                UPDATE {table_name} 
                SET refund_status = %s, refund_amount = %s, refund_time = %s, update_time = %s 
                WHERE order_no = %s
            """
            cursor.execute(sql, (refund_status, refund_amount, refund_time, datetime.now(), order_no))
            conn.commit()
            return cursor.rowcount > 0
        except Exception as e:
            logger.error(f"Failed to update recon refund status: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def batch_save_order_refund_split_sub(self, refund_split_subs: List[ReconOrderRefundSplitSub]) -> bool:
        if not refund_split_subs:
            return True
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_refund_split_sub"
            sql = f"""
                INSERT INTO {table_name} (
                    order_no, sub_order_no, merchant_id, merchant_order_no, refund_split_amount, 
                    create_time, update_time
                ) VALUES (%s, %s, %s, %s, %s, %s, %s)
            """
            params = []
            now = datetime.now()
            for sub in refund_split_subs:
                params.append((
                    sub.order_no, sub.sub_order_no, sub.merchant_id, sub.merchant_order_no,
                    sub.refund_split_amount, sub.create_time or now, sub.update_time or now
                ))
            cursor.executemany(sql, params)
            conn.commit()
            return True
        except Exception as e:
            logger.error(f"Failed to batch save refund split subs: {e}")
            return False
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def get_pending_recon_orders(self, date_str: str) -> List[ReconOrderMain]:
        # Implementation skipped for now, will add if needed by timing service
        logger.warning("get_pending_recon_orders not fully implemented")
        return []

    def get_recon_summary(self, date_str: str) -> ReconSummary:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            cursor = conn.cursor()
            table_name = "easy_recon_order_main"
            
            # Assuming date_str is YYYY-MM-DD, we filter by create_time
            # For simplicity, we assume create_time matches the date string prefix or strict range
            # Here we use DATE(create_time) = date_str logic. 
            # Note: MySQL uses DATE(), PG uses DATE(). format might differ slightly but standard ISO works.
            
            sql = f"""
                SELECT 
                    COUNT(*) as total_orders,
                    SUM(CASE WHEN recon_status = 1 THEN 1 ELSE 0 END) as success_count,
                    SUM(CASE WHEN recon_status != 1 THEN 1 ELSE 0 END) as fail_count,
                    SUM(pay_amount) as total_amount
                FROM {table_name}
                WHERE DATE(create_time) = %s
            """
            cursor.execute(sql, (date_str,))
            row = cursor.fetchone()
            
            if row:
                return ReconSummary(
                    total_orders=row[0] or 0,
                    success_count=row[1] or 0,
                    fail_count=row[2] or 0,
                    total_amount=row[3] or Decimal("0.00")
                )
            return ReconSummary()
        except Exception as e:
            logger.error(f"Failed to get recon summary: {e}")
            return ReconSummary()
        finally:
            if cursor: cursor.close()
            if conn: conn.close()

    def list_orders_by_date(self, date_str: str, page: int, size: int) -> tuple[List[ReconOrderMain], int]:
        conn = None
        cursor = None
        try:
            conn = self.get_connection()
            offset = (page - 1) * size
            
            # Total count
            cursor = conn.cursor()
            table_name = "easy_recon_order_main"
            count_sql = f"SELECT COUNT(*) FROM {table_name} WHERE DATE(create_time) = %s"
            cursor.execute(count_sql, (date_str,))
            total = cursor.fetchone()[0]
            cursor.close()
            
            # List
            if self.config.db_type == "postgresql":
                cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
            else:
                cursor = conn.cursor(dictionary=True)
                
            sql = f"SELECT * FROM {table_name} WHERE DATE(create_time) = %s LIMIT %s OFFSET %s"
            cursor.execute(sql, (date_str, size, offset))
            rows = cursor.fetchall()
            
            result = []
            for row in rows:
                result.append(ReconOrderMain(
                    order_no=row['order_no'],
                    pay_amount=row['pay_amount'],
                    platform_income=row['platform_income'],
                    pay_fee=row['pay_fee'],
                    split_total_amount=row['split_total_amount'],
                    pay_status=row['pay_status'],
                    split_status=row['split_status'],
                    notify_status=row['notify_status'],
                    recon_status=row['recon_status'],
                    notify_result=row['notify_result'],
                    create_time=row['create_time'],
                    update_time=row['update_time'],
                    refund_status=row.get('refund_status'),
                    refund_amount=row.get('refund_amount'),
                    refund_time=row.get('refund_time')
                ))
            
            return result, total
        except Exception as e:
            logger.error(f"Failed to list orders: {e}")
            return [], 0
        finally:
            if cursor: # cursor might be closed in mid-block but re-opened
                try: cursor.close() 
                except: pass
            if conn: conn.close()
